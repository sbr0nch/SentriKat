# Investigation: CVE-2026-2441 Not Appearing in SentriKat

**Date:** 2026-02-16
**CVE:** CVE-2026-2441 (Chrome 0-day — Use after free in CSS, CVSS 8.8 HIGH)
**Status:** NOT VISIBLE in SentriKat — root cause identified (3 compounding issues)

---

## Scenario

A Chrome 0-day (CVE-2026-2441) was dropped on 2026-02-13. We expected it to appear in SentriKat after running sync and admintools-remap. It did not appear.

## What We Did

1. Started the SentriKat server
2. Ran a **sync** (UI button / `POST /api/sync`)
3. Ran **admintools-remap** (`POST /api/products/apply-cpe` + `POST /api/products/rematch`)
4. CVE-2026-2441 still does not appear in the dashboard

## What We Found

Ran the NVD check manually:
```bash
curl -s "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=CVE-2026-2441" | python3 -m json.tool
```

**NVD HAS the CVE.** Key details:
- `vulnStatus: "Awaiting Analysis"` — NVD received it but hasn't fully analyzed it
- `baseScore: 8.8`, `baseSeverity: "HIGH"` (from Secondary/ADP source, not NVD primary)
- `configurations: MISSING` — **no CPE version range data** because NVD hasn't analyzed it
- `published: 2026-02-13T19:17:31` — 3 days ago
- Description: *"Use after free in CSS in Google Chrome prior to 145.0.7632.75"*

**CISA KEV:** Does NOT have it yet (confirmed).

## Root Cause — 3 Compounding Issues

There are THREE separate problems that all prevent this CVE from appearing.

---

### Problem 1: Manual sync does NOT trigger NVD import

**File:** `app/routes.py:3881` — `trigger_sync()` only calls `sync_cisa_kev()`

The "Sync" button / `POST /api/sync` only runs the CISA KEV sync. It does **NOT** call `sync_nvd_recent_cves()`. The NVD import is a separate scheduled job that runs every 2 hours.

Since CISA KEV doesn't have CVE-2026-2441, the manual sync finds nothing. The NVD scheduled job (`sync_nvd_recent_cves`) runs on its own schedule and might not have fired yet if the server just started.

**Impact:** CVE-2026-2441 may not even exist in the Vulnerability table yet.

**Evidence:**
```python
# routes.py:3881-3889
@bp.route('/api/sync', methods=['POST'])
def trigger_sync():
    result = sync_cisa_kev()   # ← Only CISA KEV, NOT NVD
    return jsonify(result)
```

---

### Problem 2: NVD import stores vendor/product as "Unknown"

**File:** `app/cisa_sync.py:1121-1167`

When `sync_nvd_recent_cves()` does run and imports CVE-2026-2441, NVD returns no `configurations` block (because `vulnStatus: "Awaiting Analysis"`). The code extracts vendor/product from CPE URIs inside `configurations`:

```python
# cisa_sync.py:1121-1132
for config in cve_data.get('configurations', []):   # ← EMPTY, loop never executes
    for node in config.get('nodes', []):
        for match in node.get('cpeMatch', []):
            ...
            vendor = parsed['vendor']
            product = parsed['product']

# Result: vendor='', product='' → stored as 'Unknown'
vuln = Vulnerability(
    vendor_project=vendor or 'Unknown',   # ← 'Unknown'
    product=product or 'Unknown',          # ← 'Unknown'
)
```

The description clearly says "Google Chrome" but the code doesn't parse the description — it only extracts vendor/product from CPE data that doesn't exist yet.

**Impact:** Even keyword matching against "Google" / "Chrome" fails because the Vulnerability record says vendor='Unknown', product='Unknown'.

Also: since `configurations` is empty, `cpe_entries = []`, so `set_cpe_entries()` is never called → `cpe_data = NULL`, `cpe_fetched_at = NULL`.

---

### Problem 3: CPE fetch marks "Awaiting Analysis" as "authoritatively not affected"

**File:** `app/cisa_sync.py:395-420` and `app/filters.py:119-132`

After the CVE is imported (with `cpe_data = NULL`), the next `fetch_cpe_version_data()` call queries NVD for CPE configurations:

```python
# cisa_sync.py:416-419
if cpe_entries:
    vuln.set_cpe_entries(cpe_entries)
else:
    # Mark as checked even if no CPE data found
    vuln.cpe_data = '[]'                         # ← Empty
    vuln.cpe_fetched_at = datetime.utcnow()      # ← STAMPED as "checked"
```

NVD returns no CPE data (still "Awaiting Analysis"), so the code sets `cpe_data = '[]'` and stamps `cpe_fetched_at`. This is intended to mean "NVD has no CPE data for this CVE."

Then during matching:

```python
# filters.py:119-132
else:   # No CPE entries
    if vulnerability.cpe_fetched_at:            # ← IS set (from fetch above)
        # NVD was already queried — no CPE data exists for this CVE.
        # Don't fall back to text matching; NVD is authoritative.
        return [], None, None                   # ← NO MATCH, EVER
```

**The code cannot distinguish between:**
- "NVD analyzed this CVE and confirmed it affects no CPE products" (legitimate)
- "NVD hasn't analyzed this CVE yet" (`vulnStatus: Awaiting Analysis` — temporary)

Once `cpe_fetched_at` is stamped, the CVE is permanently treated as "affects nothing" and will NEVER match any product. Even when NVD later completes analysis and adds CPE data, SentriKat won't re-fetch because `cpe_data` is not NULL anymore (it's `'[]'`).

**This is the fatal issue.** The CVE gets stuck in a permanent "not affected" state.

---

## Complete Failure Chain

```
1. User clicks Sync
   └─ Only runs sync_cisa_kev() → CVE not in CISA KEV → nothing imported

2. NVD scheduled job eventually runs (every 2h)
   └─ Finds CVE-2026-2441 in NVD (HIGH severity, published Feb 13)
   └─ vulnStatus = "Awaiting Analysis" → passes filter (not Rejected/Disputed)
   └─ configurations = EMPTY → vendor='Unknown', product='Unknown', cpe_entries=[]
   └─ Vulnerability created with NO CPE data, NO useful vendor/product

3. fetch_cpe_version_data() runs (during next sync_cisa_kev)
   └─ Queries NVD for CPE configurations → returns nothing (still Awaiting Analysis)
   └─ Sets cpe_data='[]', cpe_fetched_at=NOW
   └─ CVE is now permanently marked as "checked, no CPE data"

4. rematch_all_products() runs
   └─ Chrome product (cpe: google:chrome) checked against CVE-2026-2441
   └─ CVE has empty cpe_entries + cpe_fetched_at is set
   └─ filters.py:129-132 → "NVD is authoritative, no match" → SKIP
   └─ CVE never appears on dashboard

5. Even days later when NVD completes analysis:
   └─ fetch_cpe_version_data() filters by cpe_data == NULL
   └─ CVE-2026-2441 has cpe_data='[]' (not NULL) → SKIPPED
   └─ CPE data is NEVER re-fetched → CVE remains invisible forever
```

## Recommended Fixes — Implementation Details

Below are the exact code changes needed. Each fix targets a specific file and function with before/after code.

---

### Fix 1 (Quick): Add NVD import to manual sync

**File:** `app/routes.py` — lines 3878-3889
**What:** Make the manual sync button also call `sync_nvd_recent_cves()` so admins can pull NVD data on demand, not just CISA KEV.

**Current code:**
```python
@bp.route('/api/sync', methods=['POST'])
@admin_required
@limiter.limit("5/minute")
def trigger_sync():
    """
    Manually trigger CISA KEV sync

    Permissions:
    - Super Admin only: Can trigger manual sync of CISA KEV data
    """
    result = sync_cisa_kev()
    return jsonify(result)
```

**Change to:**
```python
@bp.route('/api/sync', methods=['POST'])
@admin_required
@limiter.limit("5/minute")
def trigger_sync():
    """
    Manually trigger full vulnerability sync (CISA KEV + NVD recent CVEs).

    Permissions:
    - Super Admin only: Can trigger manual sync
    """
    result = sync_cisa_kev()

    # Also run NVD recent CVEs sync for zero-day coverage
    # Without this, "Awaiting Analysis" CVEs in NVD are only picked up
    # by the 2-hour scheduled job — not by the manual sync button.
    try:
        from app.cisa_sync import sync_nvd_recent_cves
        nvd_new, nvd_skipped, nvd_errors = sync_nvd_recent_cves()
        result['nvd_new'] = nvd_new
        result['nvd_skipped'] = nvd_skipped
        result['nvd_errors'] = nvd_errors
    except Exception as e:
        logger.warning(f"NVD sync during manual trigger failed (non-critical): {e}")
        result['nvd_error'] = str(e)

    return jsonify(result)
```

---

### Fix 2 (Critical): Store NVD vulnStatus + don't stamp cpe_fetched_at for "Awaiting Analysis"

This is a two-part fix.

#### Part A: Add `nvd_status` column to Vulnerability model

**File:** `app/models.py` — line 496 (after `cpe_fetched_at`)

**Add this line after `cpe_fetched_at`:**
```python
    cpe_fetched_at = db.Column(db.DateTime, nullable=True)  # When CPE data was last fetched
    nvd_status = db.Column(db.String(50), nullable=True)  # NVD vulnStatus: Awaiting Analysis, Analyzed, etc.
```

**Migration:** After adding the column, run:
```bash
flask db migrate -m "Add nvd_status column to vulnerabilities"
flask db upgrade
```
Or if not using migrations:
```sql
ALTER TABLE vulnerabilities ADD COLUMN nvd_status VARCHAR(50);
```

#### Part B: Store vulnStatus during NVD import

**File:** `app/cisa_sync.py` — in `sync_nvd_recent_cves()`, lines 1097-1099 and 1152-1167

The `vuln_status` variable is already extracted at line 1097. Store it on the model.

**Find** (line 1152-1167):
```python
                            # Create vulnerability record
                            vuln = Vulnerability(
                                cve_id=cve_id,
                                vendor_project=vendor or 'Unknown',
                                product=product or 'Unknown',
                                vulnerability_name=description[:500],
                                date_added=datetime.utcnow().date(),
                                short_description=description,
                                required_action='Apply vendor patches. (Source: NVD)',
                                known_ransomware=False,
                                notes=f'Auto-imported from NVD (severity: {cvss_severity}).',
                                cvss_score=cvss_score,
                                severity=cvss_severity,
                                cvss_source='nvd',
                                source='nvd',
                            )
```

**Change to:**
```python
                            # Create vulnerability record
                            vuln = Vulnerability(
                                cve_id=cve_id,
                                vendor_project=vendor or 'Unknown',
                                product=product or 'Unknown',
                                vulnerability_name=description[:500],
                                date_added=datetime.utcnow().date(),
                                short_description=description,
                                required_action='Apply vendor patches. (Source: NVD)',
                                known_ransomware=False,
                                notes=f'Auto-imported from NVD (severity: {cvss_severity}).',
                                cvss_score=cvss_score,
                                severity=cvss_severity,
                                cvss_source='nvd',
                                source='nvd',
                                nvd_status=vuln_status or None,
                            )
```

#### Part C: Don't permanently stamp "Awaiting Analysis" CVEs in fetch_cpe_version_data()

**File:** `app/cisa_sync.py` — `fetch_cpe_version_data()`, lines 416-420

**Find:**
```python
            if cpe_entries:
                # Store CPE data using the model's method
                vuln.set_cpe_entries(cpe_entries)
                enriched_count += 1
                logger.debug(f"Fetched {len(cpe_entries)} CPE entries for {vuln.cve_id}")
            else:
                # Mark as checked even if no CPE data found
                vuln.cpe_data = '[]'
                vuln.cpe_fetched_at = datetime.utcnow()
                logger.debug(f"No CPE data found for {vuln.cve_id}")
```

**Change to:**
```python
            if cpe_entries:
                # Store CPE data using the model's method
                vuln.set_cpe_entries(cpe_entries)
                enriched_count += 1
                logger.debug(f"Fetched {len(cpe_entries)} CPE entries for {vuln.cve_id}")
            else:
                # Check if NVD simply hasn't analyzed this CVE yet.
                # "Awaiting Analysis" means NVD received the CVE but hasn't added
                # CPE configurations. We must NOT stamp cpe_fetched_at, otherwise
                # the matching logic permanently treats it as "not affected" and
                # the CVE is never re-checked even after NVD completes analysis.
                if getattr(vuln, 'nvd_status', None) in ('Awaiting Analysis', 'Received', 'Undergoing Analysis'):
                    logger.info(f"Skipping CPE stamp for {vuln.cve_id} — NVD status: {vuln.nvd_status} (will retry)")
                else:
                    vuln.cpe_data = '[]'
                    vuln.cpe_fetched_at = datetime.utcnow()
                    logger.debug(f"No CPE data found for {vuln.cve_id} (NVD status: {getattr(vuln, 'nvd_status', 'unknown')})")
```

**Why this works:** CVEs with `nvd_status = "Awaiting Analysis"` keep `cpe_data = NULL`, so `fetch_cpe_version_data()` will pick them up again on the next run (it queries `WHERE cpe_data IS NULL`). Once NVD completes analysis and adds CPE configs, the next fetch cycle will find them and create the match.

---

### Fix 3 (Critical): Re-fetch mechanism for stale empty CPE data

**File:** `app/cisa_sync.py` — `fetch_cpe_version_data()`, lines 392-397

Even for CVEs that WERE stamped with `cpe_data='[]'`, we need a periodic re-check in case NVD has since completed analysis.

**Find:**
```python
    # Get vulnerabilities without CPE data, prioritize:
    # 1. New CVEs (recently added to CISA KEV)
    # 2. CVEs with product matches (more urgent to get version data)
    vulns_to_fetch = Vulnerability.query.filter(
        Vulnerability.cpe_data == None
    ).order_by(Vulnerability.date_added.desc()).limit(limit).all()
```

**Change to:**
```python
    from sqlalchemy import or_

    # Get vulnerabilities needing CPE data:
    # 1. Never fetched (cpe_data IS NULL) — highest priority
    # 2. Previously empty AND older than 24h — re-check in case NVD completed analysis
    #    (NVD "Awaiting Analysis" can take days to resolve; we must not give up)
    stale_cutoff = datetime.utcnow() - timedelta(hours=24)

    vulns_to_fetch = Vulnerability.query.filter(
        or_(
            Vulnerability.cpe_data == None,
            db.and_(
                Vulnerability.cpe_data == '[]',
                Vulnerability.cpe_fetched_at < stale_cutoff
            )
        )
    ).order_by(
        # Prioritize: never-fetched first, then oldest stale re-checks
        (Vulnerability.cpe_data == None).desc(),
        Vulnerability.date_added.desc()
    ).limit(limit).all()
```

**Also add `from datetime import timedelta` at the top of the function if not already imported.**

---

### Fix 4 (Enhancement): Parse vendor/product from description as fallback

**File:** `app/cisa_sync.py` — `sync_nvd_recent_cves()`, after line 1150 (after the configurations loop)

When NVD has no `configurations` block, the vendor and product end up as empty strings (→ "Unknown"). But the description often contains the info, e.g.:
> "Use after free in CSS in **Google Chrome** prior to 145.0.7632.75"

**After the configurations loop (line 1150) and before creating the Vulnerability (line 1152), add:**

```python
                            # Fallback: extract vendor/product from description if
                            # NVD has no configurations (common for "Awaiting Analysis")
                            if not vendor and not product and description:
                                import re
                                # Common patterns: "in <Product>" or "in <Vendor> <Product>"
                                KNOWN_PRODUCTS = {
                                    r'google\s+chrome': ('Google', 'Chrome'),
                                    r'chromium': ('Chromium', 'Chromium'),
                                    r'mozilla\s+firefox': ('Mozilla', 'Firefox'),
                                    r'microsoft\s+edge': ('Microsoft', 'Edge'),
                                    r'apple\s+safari': ('Apple', 'Safari'),
                                    r'microsoft\s+windows': ('Microsoft', 'Windows'),
                                    r'linux\s+kernel': ('Linux', 'Kernel'),
                                    r'apache\s+(\w+)': ('Apache', None),  # Dynamic
                                }
                                desc_lower = description.lower()
                                for pattern, (v, p) in KNOWN_PRODUCTS.items():
                                    m = re.search(pattern, desc_lower)
                                    if m:
                                        vendor = v
                                        product = p or m.group(1).title()
                                        break
```

**Note:** This is a best-effort fallback. The KNOWN_PRODUCTS dict can be expanded over time. It ensures that even without NVD CPE data, the Vulnerability record has meaningful vendor/product fields for keyword matching.

---

### Fix 5 (Enhancement): Add manual CVE lookup by ID endpoint

**File:** `app/routes.py` — add new endpoint after `trigger_sync()` (after line 3889)

```python
@bp.route('/api/sync/cve/<cve_id>', methods=['POST'])
@admin_required
@limiter.limit("10/minute")
def lookup_single_cve(cve_id):
    """
    Manually import a single CVE by ID from NVD.

    Use case: 0-day dropped, not yet in CISA KEV or scheduled NVD sync window.
    Admin enters CVE ID → SentriKat queries NVD on-demand → imports immediately.
    """
    import re
    if not re.match(r'^CVE-\d{4}-\d{4,}$', cve_id):
        return jsonify({'error': 'Invalid CVE ID format'}), 400

    # Check if already in DB
    existing = Vulnerability.query.filter_by(cve_id=cve_id).first()
    if existing:
        return jsonify({
            'status': 'already_exists',
            'cve_id': cve_id,
            'vendor': existing.vendor_project,
            'product': existing.product,
            'cpe_data': existing.cpe_data,
            'message': f'{cve_id} already in database'
        })

    # Query NVD
    try:
        import requests
        from config import Config
        kwargs = {}
        proxies = Config.get_proxies()
        if proxies:
            kwargs['proxies'] = proxies
        if hasattr(Config, 'VERIFY_SSL'):
            kwargs['verify'] = Config.VERIFY_SSL

        headers = {}
        api_key = getattr(Config, 'NVD_API_KEY', None)
        if api_key:
            headers['apiKey'] = api_key

        resp = requests.get(
            f'https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}',
            headers=headers,
            timeout=15,
            **kwargs
        )

        if resp.status_code != 200:
            return jsonify({'error': f'NVD returned {resp.status_code}'}), 502

        data = resp.json()
        vulns = data.get('vulnerabilities', [])
        if not vulns:
            return jsonify({'error': f'{cve_id} not found in NVD'}), 404

        cve_data = vulns[0].get('cve', {})

        # Extract description
        description = ''
        for desc in cve_data.get('descriptions', []):
            if desc.get('lang') == 'en':
                description = desc.get('value', '')
                break

        if not description:
            return jsonify({'error': f'{cve_id} has no English description in NVD'}), 404

        vuln_status = cve_data.get('vulnStatus', '')

        # Extract CVSS
        cvss_score = None
        cvss_severity = None
        metrics = cve_data.get('metrics', {})
        for metric_key in ['cvssMetricV31', 'cvssMetricV30']:
            if metric_key in metrics and metrics[metric_key]:
                cvss_data_item = metrics[metric_key][0].get('cvssData', {})
                cvss_score = cvss_data_item.get('baseScore')
                cvss_severity = cvss_data_item.get('baseSeverity')
                break

        # Extract vendor/product from CPE configurations
        vendor = ''
        product_name = ''
        cpe_entries = []
        from app.nvd_cpe_api import parse_cpe_uri

        for config in cve_data.get('configurations', []):
            for node in config.get('nodes', []):
                for match in node.get('cpeMatch', []):
                    if not match.get('vulnerable', False):
                        continue
                    cpe_uri = match.get('criteria', '')
                    parsed = parse_cpe_uri(cpe_uri)
                    if not vendor and parsed.get('vendor'):
                        vendor = parsed['vendor'].replace('_', ' ').title()
                    if not product_name and parsed.get('product'):
                        product_name = parsed['product'].replace('_', ' ').title()
                    cpe_version = parsed.get('version', '*')
                    has_range = (
                        match.get('versionStartIncluding') or
                        match.get('versionStartExcluding') or
                        match.get('versionEndIncluding') or
                        match.get('versionEndExcluding')
                    )
                    cpe_entries.append({
                        'cpe_uri': cpe_uri,
                        'vendor': parsed.get('vendor', ''),
                        'product': parsed.get('product', ''),
                        'version_start': match.get('versionStartIncluding') or match.get('versionStartExcluding'),
                        'version_end': match.get('versionEndIncluding') or match.get('versionEndExcluding'),
                        'version_start_type': 'including' if match.get('versionStartIncluding') else 'excluding' if match.get('versionStartExcluding') else None,
                        'version_end_type': 'including' if match.get('versionEndIncluding') else 'excluding' if match.get('versionEndExcluding') else None,
                        'exact_version': cpe_version if (not has_range and cpe_version not in ('*', '-', '')) else None,
                    })

        # Description fallback for vendor/product (same as Fix 4)
        if not vendor and not product_name and description:
            import re as re_mod
            desc_lower = description.lower()
            for pattern, (v, p) in {
                r'google\s+chrome': ('Google', 'Chrome'),
                r'chromium': ('Chromium', 'Chromium'),
                r'mozilla\s+firefox': ('Mozilla', 'Firefox'),
                r'microsoft\s+edge': ('Microsoft', 'Edge'),
            }.items():
                m = re_mod.search(pattern, desc_lower)
                if m:
                    vendor = v
                    product_name = p
                    break

        vuln = Vulnerability(
            cve_id=cve_id,
            vendor_project=vendor or 'Unknown',
            product=product_name or 'Unknown',
            vulnerability_name=description[:500],
            date_added=datetime.utcnow().date(),
            short_description=description,
            required_action='Apply vendor patches. (Source: NVD — manual lookup)',
            known_ransomware=False,
            notes=f'Manually imported from NVD (severity: {cvss_severity}, status: {vuln_status}).',
            cvss_score=cvss_score,
            severity=cvss_severity,
            cvss_source='nvd',
            source='nvd',
        )
        if hasattr(vuln, 'nvd_status'):
            vuln.nvd_status = vuln_status

        if cpe_entries:
            vuln.set_cpe_entries(cpe_entries)

        db.session.add(vuln)
        db.session.commit()

        # Trigger rematch for this new CVE
        from app.filters import rematch_all_products
        removed, matched = rematch_all_products()

        return jsonify({
            'status': 'imported',
            'cve_id': cve_id,
            'vendor': vuln.vendor_project,
            'product': vuln.product,
            'cvss_score': cvss_score,
            'severity': cvss_severity,
            'nvd_status': vuln_status,
            'has_cpe_data': bool(cpe_entries),
            'matches_created': matched,
            'message': f'{cve_id} imported successfully'
        })

    except Exception as e:
        logger.exception(f"Manual CVE lookup failed for {cve_id}")
        return jsonify({'error': str(e)}), 500
```

**Usage from CLI or browser:**
```bash
curl -X POST http://localhost:5000/api/sync/cve/CVE-2026-2441 \
  -H "Authorization: Bearer <admin-token>"
```

---

## Implementation Priority

| Fix | Priority | Effort | Impact |
|-----|----------|--------|--------|
| Fix 1 | Quick win | 5 min | Manual sync now also pulls NVD CVEs |
| Fix 2 (Parts A-C) | **Critical** | 30 min | Prevents permanent "not affected" stamping for unanalyzed CVEs |
| Fix 3 | **Critical** | 10 min | Recovers already-stamped CVEs by re-checking after 24h |
| Fix 4 | Enhancement | 10 min | Better vendor/product for display even without CPE |
| Fix 5 | Enhancement | 20 min | Admin can pull any CVE by ID on-demand (0-day response) |

**Recommended implementation order:** Fix 2 → Fix 3 → Fix 1 → Fix 5 → Fix 4

Fix 2+3 together solve the core bug (CVEs permanently stuck as "not affected"). Fix 1 makes manual sync useful for NVD CVEs. Fix 5 is the ultimate 0-day response tool. Fix 4 is nice-to-have for display.

---

## Diagnostic Commands

### Check if CVE exists in SentriKat database
```sql
SELECT cve_id, vendor_project, product, cpe_data, cpe_fetched_at, nvd_status, source
FROM vulnerabilities WHERE cve_id = 'CVE-2026-2441';
```

### Check NVD status of the CVE
```bash
curl -s "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=CVE-2026-2441" | python3 -c "
import json, sys
data = json.load(sys.stdin)
cve = data['vulnerabilities'][0]['cve']
print(f'Status: {cve[\"vulnStatus\"]}')
print(f'Has configurations: {bool(cve.get(\"configurations\"))}')
print(f'CVSS: {cve.get(\"metrics\", {}).get(\"cvssMetricV31\", [{}])[0].get(\"cvssData\", {}).get(\"baseScore\", \"N/A\")}')
"
```

### Check if Chrome products have CPE in SentriKat
```sql
SELECT id, product_name, vendor, cpe_vendor, cpe_product, version
FROM products WHERE cpe_product = 'chrome' OR product_name ILIKE '%chrome%';
```

### Check last NVD sync time
```sql
SELECT key, value FROM system_settings WHERE key = 'last_nvd_cve_sync';
```

### Check for CVEs stuck with empty CPE data
```sql
SELECT cve_id, vendor_project, product, cpe_fetched_at, nvd_status
FROM vulnerabilities
WHERE cpe_data = '[]' AND cpe_fetched_at IS NOT NULL
ORDER BY date_added DESC;
```

## Unrelated: Portal 520 Error

Current known issue — portal endpoint (`license.sentrikat.com/api/v1/releases/latest`) not built yet. Non-blocking.
