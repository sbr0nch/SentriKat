"""
SentriKat Licensing System

Two tiers:
- Community (free): 1 user, 1 org, 50 products, no LDAP/alerts/API
- Professional (paid): Unlimited, all features

License keys are RSA-signed JSON payloads that are hardware-locked.
Each license is tied to a specific installation ID and cannot be used elsewhere.
"""

import json
import base64
import hashlib
import logging
import os
import uuid
import socket
from datetime import datetime, date
from functools import wraps
from flask import jsonify

logger = logging.getLogger(__name__)

# Installation ID file path (persists across restarts)
INSTALLATION_ID_FILE = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'data', '.installation_id')

# Public key file path (shared with generate_license.py)
PUBLIC_KEY_FILE = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'tools', '.license_keys', 'public_key.pem')

# Default RSA Public Key (fallback if no key file exists)
_DEFAULT_PUBLIC_KEY = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3vVRIgzYRX3ikhfymPhO
E2Sl13baVqnqUgWt+vwXRxNek114ToNZaOfka75HxD7bHFq6+nGscUyp+I6Uq0l5
YXYCqeA9euHhWS/uH367xOo3J2tugH+9jMxHUlnOVD+XpUv9TShePwwWIN7h5jWs
TWGHjF0yg+nOb1NjHf9UBYLhATNHsoajWEFptYlr8YtbmeegC6m3+6fF9mB0PdN9
Lp+Ty4P6GfcuCkGA1GIAFNquN+W4x1Q47n0zj7TJ/wwy4cDe2TTIRi+2xosmdXs4
jMD7apb2qLXSRm6ZHkUTw/8O1r4FrSrIIg7Yz1dpHCrs7kCafpBEQOEUobdm65TX
rwIDAQAB
-----END PUBLIC KEY-----"""

def get_license_public_key():
    """Get the public key for license validation.

    First tries to read from the key file (tools/.license_keys/public_key.pem),
    which is generated by generate_license.py --generate-keys.
    Falls back to the default embedded key if file doesn't exist.
    """
    if os.path.exists(PUBLIC_KEY_FILE):
        try:
            with open(PUBLIC_KEY_FILE, 'r') as f:
                key = f.read().strip()
                if key and '-----BEGIN PUBLIC KEY-----' in key:
                    logger.debug(f"Using public key from file: {PUBLIC_KEY_FILE}")
                    return key
        except Exception as e:
            logger.warning(f"Could not read public key file: {e}")

    logger.debug("Using default embedded public key")
    return _DEFAULT_PUBLIC_KEY

# License tiers and their limits
LICENSE_TIERS = {
    'community': {
        'name': 'Community',
        'max_users': 1,
        'max_organizations': 1,
        'max_products': 50,
        'features': [],
        'powered_by_required': True
    },
    'professional': {
        'name': 'Professional',
        'max_users': -1,  # Unlimited
        'max_organizations': -1,
        'max_products': -1,
        'features': [
            'ldap',
            'email_alerts',
            'white_label',
            'api_access',
            'backup_restore',
            'audit_export',
            'multi_org'
        ],
        'powered_by_required': False
    }
}

# Features that require Professional license
PROFESSIONAL_FEATURES = [
    'ldap',
    'email_alerts',
    'white_label',
    'api_access',
    'backup_restore',
    'audit_export',
    'multi_org',
    'push_agents'  # Agent deployment feature
]


# ============================================================================
# Installation ID - Stable Hardware Fingerprint
# ============================================================================

def get_installation_id():
    """
    Get or generate a unique, STABLE installation ID for this instance.
    This ID is persisted to disk and survives restarts.

    The ID is deterministic based on machine characteristics - it will be
    the same every time for the same installation.

    Used for hardware-locked licensing: licenses are tied to this ID.
    """
    # Try to load existing ID from file
    if os.path.exists(INSTALLATION_ID_FILE):
        try:
            with open(INSTALLATION_ID_FILE, 'r') as f:
                installation_id = f.read().strip()
                if installation_id and len(installation_id) >= 32:
                    return installation_id
        except Exception as e:
            logger.warning(f"Could not read installation ID: {e}")

    # Generate new stable installation ID
    installation_id = _generate_stable_fingerprint()

    # Save to file for persistence
    try:
        data_dir = os.path.dirname(INSTALLATION_ID_FILE)
        if data_dir and not os.path.exists(data_dir):
            os.makedirs(data_dir, exist_ok=True)

        with open(INSTALLATION_ID_FILE, 'w') as f:
            f.write(installation_id)

        logger.info(f"Generated installation ID: {installation_id[:16]}...")
    except Exception as e:
        logger.error(f"Could not save installation ID: {e}")

    return installation_id


def _generate_stable_fingerprint():
    """
    Generate a stable fingerprint for this installation.
    Uses machine characteristics that don't change.

    Components:
    - MAC address (hardware)
    - Hostname
    - Database path (identifies the specific installation)
    """
    fingerprint_parts = []

    # MAC address - stable hardware identifier
    try:
        mac = uuid.getnode()
        # uuid.getnode() returns a random value if no MAC found,
        # but it's consistent within a session
        fingerprint_parts.append(f"mac:{mac}")
    except:
        fingerprint_parts.append("mac:unknown")

    # Hostname
    try:
        hostname = socket.gethostname()
        fingerprint_parts.append(f"host:{hostname}")
    except:
        fingerprint_parts.append("host:unknown")

    # Database URI - unique per installation
    try:
        from config import Config
        db_uri = Config.SQLALCHEMY_DATABASE_URI or ''
        # Hash the DB URI for privacy
        db_hash = hashlib.sha256(db_uri.encode()).hexdigest()[:16]
        fingerprint_parts.append(f"db:{db_hash}")
    except:
        fingerprint_parts.append("db:unknown")

    # Combine and create final hash
    fingerprint_string = '|'.join(fingerprint_parts)
    full_hash = hashlib.sha256(fingerprint_string.encode()).hexdigest()

    # Format as readable installation ID: SK-INST-XXXXXXXX...
    return f"SK-INST-{full_hash[:32].upper()}"


def get_installation_id_display():
    """Get installation ID formatted for display to users."""
    inst_id = get_installation_id()
    # Return full ID for license requests
    return inst_id


# ============================================================================
# License Info Class
# ============================================================================

class LicenseInfo:
    """Holds current license information"""

    def __init__(self):
        self.edition = 'community'
        self.customer = None
        self.email = None
        self.license_id = None
        self.issued_at = None
        self.expires_at = None
        self.max_users = 1
        self.max_organizations = 1
        self.max_products = 50
        # Agent limits (from signed license - tamper-proof)
        self.max_agents = 0  # Community = 0 agents (requires Professional)
        self.max_agent_api_keys = 0
        self.features = []
        self.is_valid = False
        self.is_expired = False
        self.days_until_expiry = None
        self.error = None
        self.licensed_installation_id = None  # The installation ID this license is for
        self.is_hardware_match = False  # Does license match this installation?

    def get_effective_edition(self):
        """Get the effective edition considering expiration and hardware match."""
        if self.is_expired:
            return 'community'
        if not self.is_valid:
            return 'community'
        if not self.is_hardware_match:
            return 'community'
        return self.edition

    def get_effective_limits(self):
        """Get effective limits based on license status."""
        effective_edition = self.get_effective_edition()
        if effective_edition == 'community':
            return {
                'max_users': LICENSE_TIERS['community']['max_users'],
                'max_organizations': LICENSE_TIERS['community']['max_organizations'],
                'max_products': LICENSE_TIERS['community']['max_products'],
                'max_agents': 0,  # Community: No agents
                'max_agent_api_keys': 0
            }
        return {
            'max_users': self.max_users,
            'max_organizations': self.max_organizations,
            'max_products': self.max_products,
            'max_agents': self.max_agents,
            'max_agent_api_keys': self.max_agent_api_keys
        }

    def has_feature(self, feature):
        """Check if license includes a specific feature."""
        return self.get_effective_edition() == 'professional'

    def is_professional(self):
        """Check if this is an active, valid Professional license."""
        return (
            self.edition == 'professional' and
            self.is_valid and
            not self.is_expired and
            self.is_hardware_match
        )

    def check_limit(self, limit_type, current_count):
        """Check if a limit is exceeded."""
        effective_limits = self.get_effective_limits()

        limit_map = {
            'users': effective_limits['max_users'],
            'organizations': effective_limits['max_organizations'],
            'products': effective_limits['max_products'],
            'agents': effective_limits['max_agents'],
            'agent_api_keys': effective_limits['max_agent_api_keys']
        }

        limit = limit_map.get(limit_type, 0)
        if limit == -1:  # Unlimited
            return True, -1, None

        if current_count >= limit:
            edition = self.get_effective_edition()
            if edition == 'community':
                if limit_type in ['agents', 'agent_api_keys']:
                    return False, limit, f'Push Agents require a Professional license. Upgrade to deploy agents.'
                return False, limit, f'Community limit: {limit} {limit_type} maximum. Upgrade to Professional for unlimited.'
            return False, limit, f'License limit: {limit} {limit_type} maximum.'

        return True, limit, None

    def get_status_message(self):
        """Get a human-readable status message"""
        if self.error:
            return f'License error: {self.error}'
        if not self.is_valid:
            return 'No valid license - Community edition'
        if not self.is_hardware_match:
            return 'License not valid for this installation'
        if self.is_expired:
            return f'License expired on {self.expires_at}'
        if self.days_until_expiry is not None and self.days_until_expiry <= 30:
            return f'License expires in {self.days_until_expiry} days'
        if self.is_professional():
            return f'Professional license for {self.customer}'
        return 'Community edition'

    def to_dict(self):
        """Convert to dictionary for API responses"""
        effective_limits = self.get_effective_limits()
        effective_edition = self.get_effective_edition()
        current_installation_id = get_installation_id()

        return {
            'edition': self.edition,
            'effective_edition': effective_edition,
            'edition_name': LICENSE_TIERS.get(effective_edition, {}).get('name', 'Unknown'),
            'customer': self.customer,
            'license_id': self.license_id,
            'is_valid': self.is_valid and self.is_hardware_match,
            'is_expired': self.is_expired,
            'is_professional': self.is_professional(),
            'is_hardware_match': self.is_hardware_match,
            'expires_at': self.expires_at.isoformat() if self.expires_at else None,
            'days_until_expiry': self.days_until_expiry,
            'status_message': self.get_status_message(),
            'limits': effective_limits,
            'features': PROFESSIONAL_FEATURES if self.is_professional() else [],
            'powered_by_required': not self.is_professional(),
            'error': self.error,
            # Installation info
            'installation_id': current_installation_id,
            'licensed_installation_id': self.licensed_installation_id
        }


# ============================================================================
# License Loading and Caching
# ============================================================================

_current_license = None
_license_load_time = None
LICENSE_CACHE_SECONDS = 5


def get_license():
    """Get current license info with short caching."""
    global _current_license, _license_load_time

    now = datetime.utcnow()
    if (_current_license is None or
        _license_load_time is None or
        (now - _license_load_time).total_seconds() > LICENSE_CACHE_SECONDS):
        _current_license = load_license()
        _license_load_time = now

    return _current_license


def reload_license():
    """Force reload license from database"""
    global _current_license, _license_load_time
    _current_license = load_license()
    _license_load_time = datetime.utcnow()
    return _current_license


def load_license():
    """
    Load and validate license from database or environment.
    Checks hardware lock - license must match this installation's ID.
    """
    from app.models import SystemSettings

    license_info = LicenseInfo()
    license_key = None

    try:
        # Check database first
        setting = SystemSettings.query.filter_by(key='license_key').first()
        if setting and setting.value:
            license_key = setting.value
        else:
            # Fallback to environment variable
            env_key = os.environ.get('SENTRIKAT_LICENSE')
            if env_key:
                license_key = env_key

        if not license_key:
            return license_info

        # Validate the license (includes hardware check)
        license_info = validate_license(license_key)

    except Exception as e:
        logger.error(f"Error loading license: {e}", exc_info=True)
        license_info.error = str(e)

    return license_info


# ============================================================================
# License Validation
# ============================================================================

def validate_license(license_key):
    """
    Validate a license key and check hardware lock.

    License format: base64(json_payload).base64(signature)

    The payload contains an installation_id field that must match
    this installation's ID for the license to be valid.
    """
    license_info = LicenseInfo()

    try:
        # Development key for testing
        if license_key == 'SENTRIKAT-DEV-PROFESSIONAL':
            license_info.edition = 'professional'
            license_info.customer = 'Development Mode'
            license_info.license_id = 'DEV-001'
            license_info.is_valid = True
            license_info.is_hardware_match = True  # Dev key works everywhere
            license_info.max_users = -1
            license_info.max_organizations = -1
            license_info.max_products = -1
            license_info.max_agents = -1  # Unlimited agents in dev mode
            license_info.max_agent_api_keys = -1
            license_info.features = PROFESSIONAL_FEATURES + ['push_agents']
            logger.info("Development license activated")
            return license_info

        # Split license key into payload and signature
        parts = license_key.strip().split('.')
        if len(parts) != 2:
            license_info.error = 'Invalid license format'
            return license_info

        payload_b64, signature_b64 = parts

        # Decode payload
        try:
            payload_json = base64.urlsafe_b64decode(payload_b64 + '==').decode('utf-8')
            payload = json.loads(payload_json)
        except Exception as e:
            license_info.error = f'Failed to decode license: {e}'
            return license_info

        # Verify RSA signature
        try:
            from cryptography.hazmat.primitives import hashes, serialization
            from cryptography.hazmat.primitives.asymmetric import padding
            from cryptography.hazmat.backends import default_backend

            public_key = serialization.load_pem_public_key(
                get_license_public_key().encode(),
                backend=default_backend()
            )
            signature = base64.urlsafe_b64decode(signature_b64 + '==')
            public_key.verify(
                signature,
                payload_json.encode(),
                padding.PKCS1v15(),
                hashes.SHA256()
            )
        except Exception as e:
            license_info.error = 'Invalid license signature'
            logger.warning(f"License signature verification failed: {e}")
            return license_info

        # Parse license data
        license_info.license_id = payload.get('license_id')
        license_info.customer = payload.get('customer')
        license_info.email = payload.get('email')
        license_info.edition = payload.get('edition', 'community')
        license_info.licensed_installation_id = payload.get('installation_id')

        # Parse dates
        if payload.get('issued_at'):
            license_info.issued_at = datetime.fromisoformat(payload['issued_at']).date()

        if payload.get('expires_at'):
            license_info.expires_at = datetime.fromisoformat(payload['expires_at']).date()
            days_left = (license_info.expires_at - date.today()).days
            license_info.days_until_expiry = days_left
            license_info.is_expired = days_left < 0

        # Set limits from signed payload (tamper-proof)
        tier = LICENSE_TIERS.get(license_info.edition, LICENSE_TIERS['community'])
        limits = payload.get('limits', {})
        license_info.max_users = limits.get('max_users', tier['max_users'])
        license_info.max_organizations = limits.get('max_organizations', tier['max_organizations'])
        license_info.max_products = limits.get('max_products', tier['max_products'])
        # Agent limits - default to 0 if not in payload (backwards compatibility)
        # Professional licenses from before agent feature will need re-issue to enable agents
        default_agents = -1 if license_info.edition == 'professional' else 0
        license_info.max_agents = limits.get('max_agents', default_agents)
        license_info.max_agent_api_keys = limits.get('max_agent_api_keys', default_agents)
        license_info.features = payload.get('features', tier['features'])

        # CHECK HARDWARE LOCK
        current_installation_id = get_installation_id()
        licensed_installation_id = license_info.licensed_installation_id

        if not licensed_installation_id:
            # Legacy license without installation ID - allow for backwards compatibility
            # but log a warning
            logger.warning(f"License {license_info.license_id} has no installation_id - allowing for backwards compatibility")
            license_info.is_hardware_match = True
        elif licensed_installation_id == current_installation_id:
            # Perfect match
            license_info.is_hardware_match = True
        else:
            # Hardware mismatch - license is for different installation
            license_info.is_hardware_match = False
            license_info.error = (
                f"License is for a different installation.\n"
                f"Licensed for: {licensed_installation_id[:20]}...\n"
                f"This system:  {current_installation_id[:20]}...\n\n"
                f"Contact support to transfer this license."
            )
            logger.warning(f"Hardware mismatch: license for {licensed_installation_id[:16]}, this is {current_installation_id[:16]}")

        # Mark signature as valid (hardware check is separate)
        license_info.is_valid = True

        if license_info.is_expired:
            logger.warning(f"License {license_info.license_id} has expired")
        elif license_info.is_hardware_match:
            logger.info(f"License validated: {license_info.edition} for {license_info.customer}")

    except Exception as e:
        license_info.error = f'License validation error: {e}'
        logger.error(f"License validation error: {e}")

    return license_info


def save_license(license_key):
    """
    Save license key to database after validation.
    """
    from app.models import SystemSettings
    from app import db

    # Validate first
    license_info = validate_license(license_key)

    if not license_info.is_valid:
        return False, license_info.error or 'Invalid license key'

    if license_info.is_expired:
        return False, f'License has expired on {license_info.expires_at}'

    if not license_info.is_hardware_match:
        return False, license_info.error or 'License is not valid for this installation'

    # Save to database
    setting = SystemSettings.query.filter_by(key='license_key').first()
    if setting:
        setting.value = license_key
    else:
        setting = SystemSettings(
            key='license_key',
            value=license_key,
            category='licensing',
            description='SentriKat license key'
        )
        db.session.add(setting)

    db.session.commit()
    reload_license()

    return True, f'License activated: {license_info.edition.title()} edition for {license_info.customer}'


def remove_license():
    """Remove license and revert to Community."""
    from app.models import SystemSettings
    from app import db

    setting = SystemSettings.query.filter_by(key='license_key').first()
    if setting:
        db.session.delete(setting)
        db.session.commit()

    reload_license()
    return True, 'License removed. Reverted to Community edition.'


# ============================================================================
# Feature Gating
# ============================================================================

def requires_professional(feature=None):
    """Decorator to require Professional license for a route."""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            license_info = get_license()
            if not license_info.is_professional():
                feature_name = feature or 'This feature'
                return jsonify({
                    'error': f'{feature_name} requires a Professional license',
                    'license_required': True,
                    'current_edition': license_info.get_effective_edition()
                }), 403
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def check_user_limit():
    """Check if user limit is reached"""
    from app.models import User
    license_info = get_license()
    current_users = User.query.filter_by(is_active=True).count()
    return license_info.check_limit('users', current_users)


def check_org_limit():
    """Check if organization limit is reached"""
    from app.models import Organization
    license_info = get_license()
    current_orgs = Organization.query.count()
    return license_info.check_limit('organizations', current_orgs)


def check_product_limit():
    """Check if product limit is reached"""
    from app.models import Product
    license_info = get_license()
    current_products = Product.query.count()
    return license_info.check_limit('products', current_products)


def check_agent_limit():
    """
    Check if agent (endpoint) limit is reached.

    IMPORTANT: Counts agents GLOBALLY across all organizations.
    This prevents the multi-org bypass vulnerability where users
    create multiple organizations to get around per-org limits.

    Returns: (allowed, limit, message) tuple
    """
    from app.models import Asset
    license_info = get_license()

    # Count ALL active agents across ALL organizations (global limit)
    current_agents = Asset.query.filter_by(active=True).count()

    return license_info.check_limit('agents', current_agents)


def check_agent_api_key_limit():
    """
    Check if agent API key limit is reached.

    IMPORTANT: Counts API keys GLOBALLY across all organizations.
    This prevents the multi-org bypass vulnerability.

    Returns: (allowed, limit, message) tuple
    """
    from app.models import AgentApiKey
    license_info = get_license()

    # Count ALL active API keys across ALL organizations (global limit)
    current_keys = AgentApiKey.query.filter_by(active=True).count()

    return license_info.check_limit('agent_api_keys', current_keys)


def get_agent_usage():
    """
    Get current agent usage statistics for display.
    Returns dict with counts and limits.
    """
    from app.models import Asset, AgentApiKey
    license_info = get_license()
    limits = license_info.get_effective_limits()

    return {
        'agents': {
            'current': Asset.query.filter_by(active=True).count(),
            'limit': limits['max_agents'],
            'unlimited': limits['max_agents'] == -1
        },
        'api_keys': {
            'current': AgentApiKey.query.filter_by(active=True).count(),
            'limit': limits['max_agent_api_keys'],
            'unlimited': limits['max_agent_api_keys'] == -1
        },
        'feature_enabled': 'push_agents' in license_info.features or license_info.is_professional()
    }


# ============================================================================
# License API Routes
# ============================================================================

from flask import Blueprint, request
from app import csrf

license_bp = Blueprint('license', __name__)
csrf.exempt(license_bp)


@license_bp.route('/api/license', methods=['GET'])
def get_license_info():
    """Get current license information"""
    from app.auth import get_current_user
    from app.models import User, Organization, Product, Asset, AgentApiKey

    user = get_current_user()
    if not user:
        return jsonify({'error': 'Authentication required'}), 401

    license_info = get_license()
    response = license_info.to_dict()
    response['usage'] = {
        'users': User.query.filter_by(is_active=True).count(),
        'organizations': Organization.query.count(),
        'products': Product.query.count(),
        'agents': Asset.query.filter_by(active=True).count(),
        'agent_api_keys': AgentApiKey.query.filter_by(active=True).count()
    }
    # Include agent-specific usage info
    response['agent_usage'] = get_agent_usage()

    return jsonify(response)


@license_bp.route('/api/license', methods=['POST'])
def activate_license():
    """Activate a license key"""
    from app.auth import get_current_user
    from app.logging_config import log_audit_event

    user = get_current_user()
    if not user or not user.is_super_admin():
        return jsonify({'error': 'Super admin access required'}), 403

    data = request.get_json()
    license_key = data.get('license_key', '').strip()

    if not license_key:
        return jsonify({'error': 'License key is required'}), 400

    success, message = save_license(license_key)

    if success:
        log_audit_event('UPDATE', 'license', details=f'License activated: {message}')
        return jsonify({
            'success': True,
            'message': message,
            'license': get_license().to_dict()
        })
    else:
        return jsonify({'error': message}), 400


@license_bp.route('/api/license', methods=['DELETE'])
def deactivate_license():
    """Remove license and revert to Community"""
    from app.auth import get_current_user
    from app.logging_config import log_audit_event

    user = get_current_user()
    if not user or not user.is_super_admin():
        return jsonify({'error': 'Super admin access required'}), 403

    success, message = remove_license()
    log_audit_event('UPDATE', 'license', details='License removed')

    return jsonify({
        'success': True,
        'message': message,
        'license': get_license().to_dict()
    })


@license_bp.route('/api/license/installation-id', methods=['GET'])
def get_installation_id_api():
    """Get this installation's ID for license requests"""
    from app.auth import get_current_user

    user = get_current_user()
    if not user:
        return jsonify({'error': 'Authentication required'}), 401

    installation_id = get_installation_id()

    try:
        hostname = socket.gethostname()
    except:
        hostname = 'Unknown'

    return jsonify({
        'installation_id': installation_id,
        'hostname': hostname,
        'instructions': (
            'To request a license:\n'
            '1. Copy your Installation ID above\n'
            '2. Send it to SentriKat sales with your company details\n'
            '3. You will receive a license key locked to this installation'
        )
    })
